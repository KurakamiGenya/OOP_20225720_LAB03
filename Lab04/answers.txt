Which classes are aggregates of other classes? Checking all constructors of whole classes if they initialize for their parts?

Cart aggregates Media:
- Cart has an attribute itemsOrdered which is an ArrayList<Media>.
- The constructor of Cart initializes itemsOrdered.

Store aggregates Media:
- Store has an attribute itemsInStore which is an ArrayList<Media>.
- The constructor of Store initializes itemsInStore.

CompactDisc aggregates Track:
- CompactDisc has an attribute tracks which is an ArrayList<Track>.
- The constructor of CompactDisc initializes tracks.

-----***-----

Write constructors for parent and child classes. Remove redundant setter methods if any

Media Class:

```java
public class Media {
    private int id;
    private String title;
    private String category;
    private float cost;

    public Media(int id, String title, String category, float cost) {
        this.id = id;
        this.title = title;
        this.category = category;
        this.cost = cost;
    }

    public int getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getCategory() {
        return category;
    }

    public float getCost() {
        return cost;
    }
}
```

Disc Class (Child of Media):

```
public class Disc extends Media {
    private int length;
    private String director;

    public Disc(int id, String title, String category, float cost, int length, String director) {
        super(id, title, category, cost);
        this.length = length;
        this.director = director;
    }

    public int getLength() {
        return length;
    }

    public String getDirector() {
        return director;
    }
}
```

DigitalVideoDisc Class (Child of Disc):

```java
public class DigitalVideoDisc extends Disc {
    private static int nbDigitalVideoDiscs = 0;

    public DigitalVideoDisc(int id, String title, String category, String director, int length, float cost) {
        super(id, title, category, cost, length, director);
        nbDigitalVideoDiscs++;
    }

    public void play() {
        // Implementation of play method
    }
}
```

Book Class (Child of Media):

```java
public class Book extends Media {
    private List<String> authors;

    public Book(int id, String title, String category, float cost) {
        super(id, title, category, cost);
        this.authors = new ArrayList<>();
    }

    public void addAuthor(String authorName) {
        authors.add(authorName);
    }

    public void removeAuthor(String authorName) {
        authors.remove(authorName);
    }
}
```

CompactDisc Class (Child of Disc):

```java
public class CompactDisc extends Disc {
    private String artist;
    private List<Track> tracks;

    public CompactDisc(int id, String title, String category, String director, int length, float cost, String artist) {
        super(id, title, category, cost, length, director);
        this.artist = artist;
        this.tracks = new ArrayList<>();
    }

    public String getArtist() {
        return artist;
    }

    public void setArtist(String artist) {
        this.artist = artist;
    }

    public void addTrack(Track track) {
        tracks.add(track);
    }

    public void removeTrack(Track track) {
        tracks.remove(track);
    }

    public void play() {
        // Implementation of play method
    }
}
```

Track Class:

```java
public class Track {
    private String title;
    private int length;

    public Track(String title, int length) {
        this.title = title;
        this.length = length;
    }

    public String getTitle() {
        return title;
    }

    public int getLength() {
        return length;
    }

    public void play() {
        // Implementation of play method
    }
}
```

Cart Class:

```java
public class Cart {
    public static final int MAX_NUMBERS_ORDERED = 20;
    private List<Media> itemsOrdered;

    public Cart() {
        this.itemsOrdered = new ArrayList<>();
    }

    public void addMedia(Media media) {
        if (itemsOrdered.size() < MAX_NUMBERS_ORDERED) {
            itemsOrdered.add(media);
        }
    }

    public void removeMedia(Media media) {
        itemsOrdered.remove(media);
    }
}
```

-----***-----

When overriding the equals() method of the Object class, you will have to cast the Object parameter obj to the type of Object that you are dealing with. For example, in the Media class, you must cast the Object obj to a Media, and then check the equality of the two objectsâ€™ attributes as the above requirements (i.e. title for Media; title and length for Track). If the passing object is not an instance of Media, what happens?

If the passing object is not an instance of Media, attempting to cast it to Media will result in a ClassCastException at runtime. This is because the Java runtime system performs a check to ensure that the cast is valid. If it isn't, it throws the exception.

To avoid this exception and handle the situation gracefully, you should first check whether the object is an instance of Media using the instanceof operator before performing the cast. Here's how you can safely override the equals() method in the Media class:

```java
@Override
public boolean equals(Object obj) {
    // Check if obj is null
    if (obj == null) {
        return false;
    }

    // Check if obj is an instance of Media
    if (!(obj instanceof Media)) {
        return false;
    }

    // Cast obj to Media
    Media media = (Media) obj;

    // Compare the title attribute
    return this.title != null && this.title.equals(media.getTitle());
}
```

Key Points:
1. instanceof Check:
   - Ensures that the object can be safely cast to Media.
   - If the object is not of type Media, instanceof returns false, and no casting occurs.

2. Return false for Non-Media Objects:
   - If the object is not a Media, it's logically not equal to any Media instance, so the method returns false.

3. Graceful Handling:
   - Prevents runtime exceptions (ClassCastException) and ensures robust behavior.

Example Behavior:
- If obj is of type String and you pass it to equals(), the method will check if (!(obj instanceof Media)) and return false without attempting a cast.
- If obj is null, the method will return false without proceeding to further checks.

By using this safe implementation, you align with Java best practices for overriding equals() in a polymorphic way.

-----***-----

