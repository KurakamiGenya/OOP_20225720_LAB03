Which classes are aggregates of other classes? Checking all constructors of whole classes if they initialize for their parts?

Cart aggregates Media:
- Cart has an attribute itemsOrdered which is an ArrayList<Media>.
- The constructor of Cart initializes itemsOrdered.

Store aggregates Media:
- Store has an attribute itemsInStore which is an ArrayList<Media>.
- The constructor of Store initializes itemsInStore.

CompactDisc aggregates Track:
- CompactDisc has an attribute tracks which is an ArrayList<Track>.
- The constructor of CompactDisc initializes tracks.

-----***-----

Write constructors for parent and child classes. Remove redundant setter methods if any

Media Class:

```java
public class Media {
    private int id;
    private String title;
    private String category;
    private float cost;

    public Media(int id, String title, String category, float cost) {
        this.id = id;
        this.title = title;
        this.category = category;
        this.cost = cost;
    }

    public int getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getCategory() {
        return category;
    }

    public float getCost() {
        return cost;
    }
}
```

Disc Class (Child of Media):

```
public class Disc extends Media {
    private int length;
    private String director;

    public Disc(int id, String title, String category, float cost, int length, String director) {
        super(id, title, category, cost);
        this.length = length;
        this.director = director;
    }

    public int getLength() {
        return length;
    }

    public String getDirector() {
        return director;
    }
}
```

DigitalVideoDisc Class (Child of Disc):

```java
public class DigitalVideoDisc extends Disc {
    private static int nbDigitalVideoDiscs = 0;

    public DigitalVideoDisc(int id, String title, String category, String director, int length, float cost) {
        super(id, title, category, cost, length, director);
        nbDigitalVideoDiscs++;
    }

    public void play() {
        // Implementation of play method
    }
}
```

Book Class (Child of Media):

```java
public class Book extends Media {
    private List<String> authors;

    public Book(int id, String title, String category, float cost) {
        super(id, title, category, cost);
        this.authors = new ArrayList<>();
    }

    public void addAuthor(String authorName) {
        authors.add(authorName);
    }

    public void removeAuthor(String authorName) {
        authors.remove(authorName);
    }
}
```

CompactDisc Class (Child of Disc):

```java
public class CompactDisc extends Disc {
    private String artist;
    private List<Track> tracks;

    public CompactDisc(int id, String title, String category, String director, int length, float cost, String artist) {
        super(id, title, category, cost, length, director);
        this.artist = artist;
        this.tracks = new ArrayList<>();
    }

    public String getArtist() {
        return artist;
    }

    public void setArtist(String artist) {
        this.artist = artist;
    }

    public void addTrack(Track track) {
        tracks.add(track);
    }

    public void removeTrack(Track track) {
        tracks.remove(track);
    }

    public void play() {
        // Implementation of play method
    }
}
```

Track Class:

```java
public class Track {
    private String title;
    private int length;

    public Track(String title, int length) {
        this.title = title;
        this.length = length;
    }

    public String getTitle() {
        return title;
    }

    public int getLength() {
        return length;
    }

    public void play() {
        // Implementation of play method
    }
}
```

Cart Class:

```java
public class Cart {
    public static final int MAX_NUMBERS_ORDERED = 20;
    private List<Media> itemsOrdered;

    public Cart() {
        this.itemsOrdered = new ArrayList<>();
    }

    public void addMedia(Media media) {
        if (itemsOrdered.size() < MAX_NUMBERS_ORDERED) {
            itemsOrdered.add(media);
        }
    }

    public void removeMedia(Media media) {
        itemsOrdered.remove(media);
    }
}
```

-----***-----

When overriding the equals() method of the Object class, you will have to cast the Object parameter obj to the type of Object that you are dealing with. For example, in the Media class, you must cast the Object obj to a Media, and then check the equality of the two objectsâ€™ attributes as the above requirements (i.e. title for Media; title and length for Track). If the passing object is not an instance of Media, what happens?

If the passing object is not an instance of Media, attempting to cast it to Media will result in a ClassCastException at runtime. This is because the Java runtime system performs a check to ensure that the cast is valid. If it isn't, it throws the exception.

To avoid this exception and handle the situation gracefully, you should first check whether the object is an instance of Media using the instanceof operator before performing the cast. Here's how you can safely override the equals() method in the Media class:

```java
@Override
public boolean equals(Object obj) {
    // Check if obj is null
    if (obj == null) {
        return false;
    }

    // Check if obj is an instance of Media
    if (!(obj instanceof Media)) {
        return false;
    }

    // Cast obj to Media
    Media media = (Media) obj;

    // Compare the title attribute
    return this.title != null && this.title.equals(media.getTitle());
}
```

Key Points:
1. instanceof Check:
   - Ensures that the object can be safely cast to Media.
   - If the object is not of type Media, instanceof returns false, and no casting occurs.

2. Return false for Non-Media Objects:
   - If the object is not a Media, it's logically not equal to any Media instance, so the method returns false.

3. Graceful Handling:
   - Prevents runtime exceptions (ClassCastException) and ensures robust behavior.

Example Behavior:
- If obj is of type String and you pass it to equals(), the method will check if (!(obj instanceof Media)) and return false without attempting a cast.
- If obj is null, the method will return false without proceeding to further checks.

By using this safe implementation, you align with Java best practices for overriding equals() in a polymorphic way.

-----***-----

What class should implement the Comparable interface?

The Media class should implement the Comparable interface. Since Media is the base class for all types of media (e.g., DVDs, CDs), implementing Comparable here will ensure that all subclasses inherit this ordering behavior unless they override it.

-----***-----

In those classes, how should you implement the compareTo() method to reflect the ordering that we want?

To reflect the desired ordering, the compareTo() method in the Media class can implement either:

- Ordering by title, then cost:
```java
@Override
public int compareTo(Media other) {
    int titleComparison = this.title.compareToIgnoreCase(other.title);
    if (titleComparison != 0) {
        return titleComparison;
    }
    return Float.compare(this.cost, other.cost);
}
```

- Ordering by cost, then title:
```java
@Override
public int compareTo(Media other) {
    int costComparison = Float.compare(other.cost, this.cost); // Descending cost
    if (costComparison != 0) {
        return costComparison;
    }
    return this.title.compareToIgnoreCase(other.title); // Ascending title
}
```

However, since the Comparable interface supports only one ordering rule, we cannot directly have both rules simultaneously using this approach.

-----***-----

Can we have two ordering rules of the item (by title then cost and by cost then title) if we use this Comparable interface approach?

No, we cannot have two ordering rules using the Comparable interface because a class implementing Comparable can only define a single natural ordering via the compareTo() method.

To achieve multiple ordering rules, we must rely on the Comparator interface instead, as it allows us to define multiple comparison logic and pass the desired comparator dynamically when sorting.

-----***-----

Suppose DVDs have a different ordering rule from the other media types, that is by title, then decreasing length, then cost. How would you modify your code to allow this?

If DVDs require a specific ordering rule, we can override the compareTo() method in the DigitalVideoDisc subclass (assuming DVDs are represented by this class). The subclass-specific logic would ensure that DVDs are sorted differently while other media types use the Media class's natural ordering.

Here is how the compareTo() method in the DigitalVideoDisc class would look:

```java
package hust.soict.dsai.aims.media;

public class DigitalVideoDisc extends Media {
    private int length;

    // Getter and setter for length...

    @Override
    public int compareTo(Media other) {
        if (other instanceof DigitalVideoDisc) {
            DigitalVideoDisc otherDvd = (DigitalVideoDisc) other;
            int titleComparison = this.getTitle().compareToIgnoreCase(otherDvd.getTitle());
            if (titleComparison != 0) {
                return titleComparison;
            }
            int lengthComparison = Integer.compare(otherDvd.getLength(), this.getLength()); // Descending length
            if (lengthComparison != 0) {
                return lengthComparison;
            }
            return Float.compare(this.getCost(), otherDvd.getCost()); // Ascending cost
        }
        return super.compareTo(other); // Use default Media comparison for non-DVD types
    }
}
```

In this way:
- DVDs have their own ordering logic based on title, decreasing length, and then cost.
- Other media types follow the default ordering defined in the Media class.

To sort the cart, the itemsOrdered list can still use Collections.sort() directly because the compareTo() method is defined appropriately in each class.